#!groovy
import bcgov.GitHubHelper

// --------------------
// Declarative Pipeline
// --------------------
pipeline {
  agent any

  environment {
    // Enable pipeline verbose debug output if greater than 0
    DEBUG_OUTPUT = 'false'

    // Get projects/namespaces from config maps
    DEV_PROJECT = new File('/var/run/configs/ns/project.dev').getText('UTF-8').trim()
    TEST_PROJECT = new File('/var/run/configs/ns/project.test').getText('UTF-8').trim()
    PROD_PROJECT = new File('/var/run/configs/ns/project.prod').getText('UTF-8').trim()
    TOOLS_PROJECT = new File('/var/run/configs/ns/project.tools').getText('UTF-8').trim()

    // Get application config from config maps
    REPO_OWNER = new File('/var/run/configs/jobs/repo.owner').getText('UTF-8').trim()
    REPO_NAME = new File('/var/run/configs/jobs/repo.name').getText('UTF-8').trim()
    APP_NAME = new File('/var/run/configs/jobs/app.name').getText('UTF-8').trim()
    APP_DOMAIN = new File('/var/run/configs/jobs/app.domain').getText('UTF-8').trim()

    // JOB_NAME should be the pull request/branch identifier (i.e. 'pr-5')
    JOB_NAME = JOB_BASE_NAME.toLowerCase()

    // SOURCE_REPO_* references git repository resources
    SOURCE_REPO_RAW = "https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/master"
    SOURCE_REPO_REF = "pull/${CHANGE_ID}/head"
    SOURCE_REPO_URL = "https://github.com/${REPO_OWNER}/${REPO_NAME}.git"

    // HOST_ROUTE is the full domain without the path (ie. 'appname-k8vopl-dev.pathfinder.gov.bc.ca/pr-5')
    DEV_HOST = "${APP_NAME}-${DEV_PROJECT}.${APP_DOMAIN}"
    // will be added to the HOST_ROUTE
    PATH_ROOT = "/${JOB_NAME}"
  }

  stages {
    stage('Init') {
      steps {
        notifyStageStatus('Init', 'PENDING')

        // Cancel any running builds in progress
        timeout(5) {
          echo "Cancelling previous ${APP_NAME}-${JOB_NAME} builds in progress..."
          abortAllPreviousBuildInProgress(currentBuild)
        }

        script {
          if(DEBUG_OUTPUT.equalsIgnoreCase('true')) {
            // Force OpenShift Plugin directives to be verbose
            openshift.logLevel(1)

            // Print all environment variables
            echo 'DEBUG - All pipeline environment variables:'
            echo sh(returnStdout: true, script: 'env')
          }

        }
      }
      post {
        success {
          echo 'Init successful'
          notifyStageStatus('Init', 'SUCCESS')
        }
        unsuccessful {
          echo 'Init failed'
          notifyStageStatus('Init', 'FAILURE')
        }
      }
    }

    stage('NpmImages') {
      steps {
          notifyStageStatus('NpmImages', 'PENDING')
          script {
            openshift.withCluster() {
              openshift.withProject(TOOLS_PROJECT) {
                if(DEBUG_OUTPUT.equalsIgnoreCase('true')) {
                  echo "DEBUG - Using project: ${openshift.project()}"
                }

                def pipelineUpdated = jenkinsFileUpdated()

                def packagesBackendUpdate = backendPackagesUpdated()
                echo "backend/package.json updated: ${packagesBackendUpdate}"
                def backendNpmImageExists = openshift.selector('is', "${APP_NAME}-${JOB_NAME}-backend-npm").exists()
                echo "backend builder image exists: ${backendNpmImageExists}"
                def backendNpmTemplateChanged = backendNpmTemplateUpdated()
                echo "backend npm template updated: ${backendNpmTemplateChanged}"

                def packagesFrontendUpdate = frontendPackagesUpdated();
                echo "frontend/package.json updated: ${packagesFrontendUpdate}"
                def frontendNpmImageExists = openshift.selector('is', "${APP_NAME}-${JOB_NAME}-frontend-npm").exists()
                echo "frontend npm image exists: ${frontendNpmImageExists}"
                def frontendNpmTemplateChanged = frontendNpmTemplateUpdated()
                echo "frontend npm template updated: ${frontendNpmTemplateChanged}"


                parallel(
                  Backend: {
                    if (pipelineUpdated || packagesBackendUpdate || backendNpmTemplateChanged || !backendNpmImageExists) {
                      echo "Changes to backend NPM, update and build..."
                      echo "Processing BuildConfig ${APP_NAME}-${JOB_NAME}-backend-npm..."
                      def bcBackendNpmTemplate = openshift.process('-f',
                        'openshift/backend-npm.bc.yaml',
                        "REPO_NAME=${REPO_NAME}",
                        "JOB_NAME=${JOB_NAME}",
                        "SOURCE_REPO_URL=${SOURCE_REPO_URL}",
                        "SOURCE_REPO_REF=${SOURCE_REPO_REF}",
                        "APP_NAME=${APP_NAME}"
                      )

                      echo "Building ImageStream ${APP_NAME}-${JOB_NAME}-backend-npm..."
                      openshift.apply(bcBackendNpmTemplate).narrow('bc').startBuild('-w').logs('-f')

                    } else {
                      echo "backend npm up to date."
                    }

                  },
                  Frontend: {
                    if (pipelineUpdated || packagesFrontendUpdate || frontendNpmTemplateChanged || !frontendNpmImageExists) {
                      echo "Changes to frontend NPM, update and build..."
                      echo "Processing BuildConfig ${APP_NAME}-${JOB_NAME}-frontend-npm..."
                      def bcFrontendNpmTemplate = openshift.process('-f',
                        'openshift/frontend-npm.bc.yaml',
                        "REPO_NAME=${REPO_NAME}",
                        "JOB_NAME=${JOB_NAME}",
                        "SOURCE_REPO_URL=${SOURCE_REPO_URL}",
                        "SOURCE_REPO_REF=${SOURCE_REPO_REF}",
                        "APP_NAME=${APP_NAME}"
                      )

                      echo "Building ImageStream ${APP_NAME}-${JOB_NAME}-frontend-npm..."
                      openshift.apply(bcFrontendNpmTemplate).narrow('bc').startBuild('-w').logs('-f')

                    } else {
                      echo "frontend npm up to date."
                    }

                  }
                )
              }
            }
          }
      }
      post {
        success {
          echo 'NpmImages successful'
          notifyStageStatus('NpmImages', 'SUCCESS')
          script {
            openshift.withCluster() {
              openshift.withProject(TOOLS_PROJECT) {
                if(DEBUG_OUTPUT.equalsIgnoreCase('true')) {
                  echo "DEBUG - Using project: ${openshift.project()}"
                } else {
                  def bcBackendNpmConfig = openshift.selector('bc', "${APP_NAME}-${JOB_NAME}-backend-npm")
                  def bcFrontendNpmConfig = openshift.selector('bc', "${APP_NAME}-${JOB_NAME}-frontend-npm")

                  if(bcBackendNpmConfig.exists()) {
                    echo "Removing BuildConfig ${APP_NAME}-${JOB_NAME}-backend-npm..."
                    bcBackendNpmConfig.delete()
                  }

                  if(bcFrontendNpmConfig.exists()) {
                    echo "Removing BuildConfig ${APP_NAME}-${JOB_NAME}-frontend-npm..."
                    bcFrontendNpmConfig.delete()
                  }
                }
              }
            }
          }
        }
        unsuccessful {
          echo 'NpmImages failed'
          notifyStageStatus('NpmImages', 'FAILURE')
        }
      }
    }

    stage('BuilderImages') {
      steps {
          notifyStageStatus('BuilderImages', 'PENDING')
          script {
            openshift.withCluster() {
              openshift.withProject(TOOLS_PROJECT) {
                if(DEBUG_OUTPUT.equalsIgnoreCase('true')) {
                  echo "DEBUG - Using project: ${openshift.project()}"
                }

                def frontendChanged = frontendUpdated();
                echo "frontend/* updated: ${frontendChanged}"
                def frontendBuilderImageExists = openshift.selector('is', "${APP_NAME}-${JOB_NAME}-frontend-builder").exists()
                echo "frontend builder image exists: ${frontendBuilderImageExists}"
                def frontendBuilderTemplateChanged = frontendBuilderTemplateUpdated()
                echo "frontend builder template updated: ${frontendBuilderTemplateChanged}"

                if (jenkinsFileUpdated() || frontendChanged || frontendBuilderTemplateChanged || !frontendBuilderImageExists) {
                  echo "Changes to frontend builder, update and build..."
                  echo "Processing BuildConfig ${APP_NAME}-${JOB_NAME}-frontend-builder..."
                  def bcFrontendBuilderTemplate = openshift.process('-f',
                    'openshift/frontend-builder.bc.yaml',
                    "REPO_NAME=${REPO_NAME}",
                    "JOB_NAME=${JOB_NAME}",
                    "SOURCE_REPO_URL=${SOURCE_REPO_URL}",
                    "SOURCE_REPO_REF=${SOURCE_REPO_REF}",
                    "APP_NAME=${APP_NAME}",
                    "PATH_ROOT=${PATH_ROOT}"
                  )

                  echo "Building ImageStream ${APP_NAME}-${JOB_NAME}-frontend-builder..."
                  openshift.apply(bcFrontendBuilderTemplate).narrow('bc').startBuild('-w').logs('-f')

                } else {
                  echo "frontend/* and builder image up to date."
                }
              }
            }
          }
      }
      post {
        success {
          echo 'BuilderImages successful'
          notifyStageStatus('BuilderImages', 'SUCCESS')
          script {
            openshift.withCluster() {
              openshift.withProject(TOOLS_PROJECT) {
                if(DEBUG_OUTPUT.equalsIgnoreCase('true')) {
                  echo "DEBUG - Using project: ${openshift.project()}"
                } else {
                  def bcFrontendBuilderConfig = openshift.selector('bc', "${APP_NAME}-${JOB_NAME}-frontend-builder")

                  if(bcFrontendBuilderConfig.exists()) {
                    echo "Removing BuildConfig ${APP_NAME}-${JOB_NAME}-frontend-builder..."
                    bcFrontendBuilderConfig.delete()
                  }
                }
              }
            }
          }
        }
        unsuccessful {
          echo 'BuilderImages'
          notifyStageStatus('BuilderImages', 'FAILURE')
        }
      }
    }

    stage('RuntimeImages') {
      steps {
        notifyStageStatus('RuntimeImages', 'PENDING')
        script {
          openshift.withCluster() {
            openshift.withProject(TOOLS_PROJECT) {
              if(DEBUG_OUTPUT.equalsIgnoreCase('true')) {
                echo "DEBUG - Using project: ${openshift.project()}"
              }

              // for whatever reason, watching related builds is not reliable.
              // the watches don't always close even when build is complete.
              //  openshift.selector("bc", "${APP_NAME}-${JOB_NAME}-backend").related('builds').untilEach(1) {
              //    echo "build: ${it.name()}, status.phase: ${it.object().status.phase}"
              //    return (it.object().status.phase == "Complete")
              //  }
              //
              // so build out in parallel with explicit wait
              echo "Processing BuildConfig ${APP_NAME}-${JOB_NAME}-backend..."
              def bcBackendTemplate = openshift.process('-f',
                'openshift/backend.bc.yaml',
                "REPO_NAME=${REPO_NAME}",
                "JOB_NAME=${JOB_NAME}",
                "SOURCE_REPO_URL=${SOURCE_REPO_URL}",
                "SOURCE_REPO_REF=${SOURCE_REPO_REF}",
                "APP_NAME=${APP_NAME}"
              )

              echo "Processing BuildConfig ${APP_NAME}-${JOB_NAME}-frontend..."
              def bcFrontendTemplate = openshift.process('-f',
                'openshift/frontend.bc.yaml',
                "REPO_NAME=${REPO_NAME}",
                "JOB_NAME=${JOB_NAME}",
                "SOURCE_REPO_URL=${SOURCE_REPO_URL}",
                "SOURCE_REPO_REF=${SOURCE_REPO_REF}",
                "APP_NAME=${APP_NAME}"
              )

              echo "Processing BuildConfig ${APP_NAME}-${JOB_NAME}-reverse-proxy..."
              def bcReverseProxyTemplate = openshift.process('-f',
                'openshift/reverse-proxy.bc.yaml',
                "REPO_NAME=${REPO_NAME}",
                "JOB_NAME=${JOB_NAME}",
                "SOURCE_REPO_URL=${SOURCE_REPO_URL}",
                "SOURCE_REPO_REF=${SOURCE_REPO_REF}",
                "APP_NAME=${APP_NAME}"
              )

              timeout(10) {
                parallel(
                  Backend: {
                    try {
                      notifyStageStatus('Backend', 'PENDING')

                      echo "Building ImageStream ${APP_NAME}-${JOB_NAME}-backend..."
                      openshift.apply(bcBackendTemplate).narrow('bc').startBuild('-w').logs('-f')

                      echo 'Backend build successful'
                      notifyStageStatus('Backend', 'SUCCESS')
                    } catch (e) {
                      echo 'Backend build failed'
                      notifyStageStatus('Backend', 'FAILURE')
                      throw e
                    }
                  },

                  Frontend: {
                    try {
                      notifyStageStatus('Frontend', 'PENDING')

                      echo "Building ImageStream ${APP_NAME}-${JOB_NAME}-frontend..."
                      openshift.apply(bcFrontendTemplate).narrow('bc').startBuild('-w').logs('-f')

                      echo 'Frontend build successful'
                      notifyStageStatus('Frontend', 'SUCCESS')
                    } catch (e) {
                      echo 'Frontend build failed'
                      notifyStageStatus('Frontend', 'FAILURE')
                      throw e
                    }
                  },

                  ReverseProxy: {
                    try {
                      notifyStageStatus('ReverseProxy', 'PENDING')

                      echo "Building ImageStream ${APP_NAME}-${JOB_NAME}-reverse-proxy..."
                      openshift.apply(bcReverseProxyTemplate).narrow('bc').startBuild('-w').logs('-f')

                      echo 'ReverseProxy build successful'
                      notifyStageStatus('ReverseProxy', 'SUCCESS')
                    } catch (e) {
                      echo 'ReverseProxy build failed'
                      notifyStageStatus('ReverseProxy', 'FAILURE')
                      throw e
                    }
                  }
                )
              }
            }
          }
        }
      }
      post {
        success {
          echo 'RuntimeImages Success'
          notifyStageStatus('RuntimeImages', 'SUCCESS')
          echo 'Cleanup BuildConfigs...'
          script {
            openshift.withCluster() {
              openshift.withProject(TOOLS_PROJECT) {
                if(DEBUG_OUTPUT.equalsIgnoreCase('true')) {
                  echo "DEBUG - Using project: ${openshift.project()}"
                } else {
                  def bcBackendConfig = openshift.selector('bc', "${APP_NAME}-${JOB_NAME}-backend")
                  def bcFrontendConfig = openshift.selector('bc', "${APP_NAME}-${JOB_NAME}-frontend")
                  def bcReverseProxyConfig = openshift.selector('bc', "${APP_NAME}-${JOB_NAME}-reverse-proxy")

                  if(bcBackendConfig.exists()) {
                    echo "Removing BuildConfig ${APP_NAME}-${JOB_NAME}-backend..."
                    bcBackendConfig.delete()
                  }
                  if(bcFrontendConfig.exists()) {
                    echo "Removing BuildConfig ${APP_NAME}-${JOB_NAME}-frontend..."
                    bcFrontendConfig.delete()
                  }
                  if(bcReverseProxyConfig.exists()) {
                    echo "Removing BuildConfig ${APP_NAME}-${JOB_NAME}-reverse-proxy..."
                    bcReverseProxyConfig.delete()
                  }
                }
              }
            }
          }
        }
        unsuccessful {
          echo 'RuntimeImages failed'
          notifyStageStatus('RuntimeImages', 'FAILURE')
        }
      }
    }

    stage('Deploy - Dev') {
      steps {
        script {
          deployStage('Dev', DEV_PROJECT, DEV_HOST, PATH_ROOT)
        }
      }
      post {
        success {
          createDeploymentStatus(DEV_PROJECT, 'SUCCESS', DEV_HOST, PATH_ROOT)
          notifyStageStatus('Deploy - Dev', 'SUCCESS')
        }
        unsuccessful {
          createDeploymentStatus(DEV_PROJECT, 'FAILURE', DEV_HOST, PATH_ROOT)
          notifyStageStatus('Deploy - Dev', 'FAILURE')
        }
      }
    }


  }
}

// ------------------
// Pipeline Functions
// ------------------

// Parameterized deploy stage
def deployStage(String stageEnv, String projectEnv, String hostEnv, String pathEnv) {
  if (!stageEnv.equalsIgnoreCase('Dev')) {
    input("Deploy to ${projectEnv}?")
  }

  notifyStageStatus("Deploy - ${stageEnv}", 'PENDING')

  openshift.withCluster() {
    openshift.withProject(projectEnv) {
      if(DEBUG_OUTPUT.equalsIgnoreCase('true')) {
        echo "DEBUG - Using project: ${openshift.project()}"
      }

      echo "Checking for ConfigMaps and Secrets in project ${openshift.project()}..."
      if(!(openshift.selector('cm', "cmsg-config").exists() &&
      openshift.selector('secret', "cmsg-client").exists())) {
        echo 'Some ConfigMaps and/or Secrets are missing. Please consult the openshift readme for details.'
        throw e
      }

      // "move" images from tools project to our target environment and deploy from there...
      echo "Tagging Image ${APP_NAME}-${JOB_NAME}-backend:latest..."
      openshift.tag("${TOOLS_PROJECT}/${APP_NAME}-${JOB_NAME}-backend:latest", "${APP_NAME}-${JOB_NAME}-backend:latest")

      echo "Tagging Image ${APP_NAME}-${JOB_NAME}-frontend:latest..."
      openshift.tag("${TOOLS_PROJECT}/${APP_NAME}-${JOB_NAME}-frontend:latest", "${APP_NAME}-${JOB_NAME}-frontend:latest")

      echo "Tagging Image ${APP_NAME}-${JOB_NAME}-reverse-proxy:latest..."
      openshift.tag("${TOOLS_PROJECT}/${APP_NAME}-${JOB_NAME}-reverse-proxy:latest", "${APP_NAME}-${JOB_NAME}-reverse-proxy:latest")

      // watching related pods is not reliable, particularly if this not the first deployment.
      // get "false" positives that the pods we launched are running.
      //  openshift.selector("dc", "${APP_NAME}-${JOB_NAME}-backend").related('pods').untilEach(1) {
      //    echo "backend pod: ${it.name()}, status.phase: ${it.object().status.phase}"
      //    return (it.object().status.phase == "Running")
      //  }
      //
      // so build out in parallel with explicit wait

      timeout(10) {
        parallel(
          Backend: {
            echo "Processing DeploymentConfig ${APP_NAME}-${JOB_NAME}-backend..."
            def dcBackendTemplate = openshift.process('-f',
              'openshift/backend.dc.yaml',
              "REPO_NAME=${REPO_NAME}",
              "JOB_NAME=${JOB_NAME}",
              "NAMESPACE=${projectEnv}",
              "APP_NAME=${APP_NAME}"
            )
            echo "Applying Deployment ${APP_NAME}-${JOB_NAME}-backend..."
            createDeploymentStatus(projectEnv, 'PENDING', hostEnv, pathEnv)
            openshift.apply(dcBackendTemplate).narrow('dc').rollout().latest().status()
          },

          Frontend: {
            echo "Processing DeploymentConfig ${APP_NAME}-${JOB_NAME}-frontend..."
            def dcFrontendTemplate = openshift.process('-f',
              'openshift/frontend.dc.yaml',
              "REPO_NAME=${REPO_NAME}",
              "JOB_NAME=${JOB_NAME}",
              "NAMESPACE=${projectEnv}",
              "APP_NAME=${APP_NAME}",
              "PATH_ROOT=${pathEnv}"
            )
            echo "Applying Deployment ${APP_NAME}-${JOB_NAME}-frontend..."
            createDeploymentStatus(projectEnv, 'PENDING', hostEnv, pathEnv)
            openshift.apply(dcFrontendTemplate).narrow('dc').rollout().latest().status()
          },

          ReverseProxy: {
            echo "Processing DeploymentConfig ${APP_NAME}-${JOB_NAME}-reverse-proxy..."
            def dcProxyTemplate = openshift.process('-f',
              'openshift/reverse-proxy.dc.yaml',
              "REPO_NAME=${REPO_NAME}",
              "JOB_NAME=${JOB_NAME}",
              "NAMESPACE=${projectEnv}",
              "APP_NAME=${APP_NAME}",
              "HOST_ROUTE=${hostEnv}",
              "PATH_ROOT=${pathEnv}"
            )
            echo "Applying Deployment ${APP_NAME}-${JOB_NAME}-reverse-proxy..."
            createDeploymentStatus(projectEnv, 'PENDING', hostEnv, pathEnv)
            openshift.apply(dcProxyTemplate).narrow('dc').rollout().latest().status()

          }

        )
      }
    }
  }
}

// --------------------
// Supporting Functions
// --------------------

// Notify stage status and pass to Jenkins-GitHub library
def notifyStageStatus(String name, String status) {
  def sha1 = GIT_COMMIT
  if(JOB_BASE_NAME.startsWith('PR-')) {
    sha1 = GitHubHelper.getPullRequestLastCommitId(this)
  }

  GitHubHelper.createCommitStatus(
    this, sha1, status, BUILD_URL, '', "Stage: ${name}"
  )
}

// Create deployment status and pass to Jenkins-GitHub library
def createDeploymentStatus (String environment, String status, String hostEnv, String pathEnv) {
  def ghDeploymentId = new GitHubHelper().createDeployment(
    this,
    SOURCE_REPO_REF,
    [
      'environment': environment,
      'task': "deploy:pull:${CHANGE_ID}"
    ]
  )

  new GitHubHelper().createDeploymentStatus(
    this,
    ghDeploymentId,
    status,
    ['targetUrl': "https://${hostEnv}${pathEnv}"]
  )

  if (status.equalsIgnoreCase('SUCCESS')) {
    echo "${environment} deployment successful at https://${hostEnv}${pathEnv}"
  } else if (status.equalsIgnoreCase('PENDING')) {
    echo "${environment} deployment pending..."
  } else if (status.equalsIgnoreCase('FAILURE')) {
    echo "${environment} deployment failed"
  }
}

// Creates a comment and pass to Jenkins-GitHub library
def commentOnPR(String comment) {
  if(JOB_BASE_NAME.startsWith('PR-')) {
    GitHubHelper.commentOnPullRequest(this, comment)
  }
}

def jenkinsFileUpdated() {
  def commitFiles = sh(script:"git diff --name-only HEAD~1..HEAD | grep '^Jenkinsfile.cicd' || echo -n ''", returnStatus: false, returnStdout: true).trim()
  return commitFiles.length() > 0
}

def backendPackagesUpdated() {
  def commitFiles = sh(script:"git diff --name-only HEAD~1..HEAD | grep '^backend/package.json' || echo -n ''", returnStatus: false, returnStdout: true).trim()
  return commitFiles.length() > 0
}

def backendNpmTemplateUpdated() {
  def commitFiles = sh(script:"git diff --name-only HEAD~1..HEAD | grep '^openshift/backend-npm.bc.yaml' || echo -n ''", returnStatus: false, returnStdout: true).trim()
  return commitFiles.length() > 0
}

def backendUpdated() {
  def commitFiles = sh(script:"git diff --name-only HEAD~1..HEAD | grep '^backend/' || echo -n ''", returnStatus: false, returnStdout: true).trim()
  return commitFiles.length() > 0
}

def frontendPackagesUpdated() {
  def commitFiles = sh(script:"git diff --name-only HEAD~1..HEAD | grep '^frontend/package.json' || echo -n ''", returnStatus: false, returnStdout: true).trim()
  return commitFiles.length() > 0
}

def frontendNpmTemplateUpdated() {
  def commitFiles = sh(script:"git diff --name-only HEAD~1..HEAD | grep '^openshift/frontend-npm.bc.yaml' || echo -n ''", returnStatus: false, returnStdout: true).trim()
  return commitFiles.length() > 0
}

def frontendBuilderTemplateUpdated() {
  def commitFiles = sh(script:"git diff --name-only HEAD~1..HEAD | grep '^openshift/frontend-builder.bc.yaml' || echo -n ''", returnStatus: false, returnStdout: true).trim()
  return commitFiles.length() > 0
}

def frontendUpdated() {
  def commitFiles = sh(script:"git diff --name-only HEAD~1..HEAD | grep '^frontend/' || echo -n ''", returnStatus: false, returnStdout: true).trim()
  return commitFiles.length() > 0
}


